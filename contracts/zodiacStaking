/**

ï½šï½ï½„ï½‰ï½ï½ƒï¼ï½„ï½…ï½–

ğ™³ğšğšŠğš› ğ™´ğšğš’ğšğš˜ğš›

ğšğš‘ğš’ğšœ ğš’ğšœ ğšğš‘ğš ğš£ğš˜ğšğš’ğšŠğšŒ ğšœğš™ğšğšŠğš”ğš’ğš—ğš...

ğš’ ğš‘ğšŠğšŸğš ğšŠ ğšğšŠğš–ğš... ğšŠ ğšŸğšğš›ğš¢ ğšœğš’ğš–ğš™ğš•ğš ğšğšŠğš–ğš...

ğšŠ ğšœğšğš›ğš’ğšğšœ ğš˜ğš ğšŒğš•ğšğšğšœ (ğšŒğš’ğš™ğš‘ğšğš›ğšœ, ğš›ğš’ğšğšğš•ğšğšœ, ğšœğš’ğšğš—ğšœ, ğš‘ğšğš—ğšğšœ, ğš•ğšğšŠğšğšœ, ğ™½ğ™µğšƒğšœ) ğš ğš’ğš•ğš• ğšğšğš’ğšğš ğš¢ğš˜ğš ğšğš˜ ğšğš‘ğš ğšğš’ğšœğšŒğš˜ğšŸğšğš›ğš¢ 
ğš˜ğš ğšğš‘ğš ğš£ğš˜ğšğš’ğšŠğšŒ ğš ğšŠğš•ğš•ğšğš'ğšœ ğšœğšğšŒğš›ğšğš ğš™ğšŠğšœğšœğš™ğš‘ğš›ğšŠğšœğš

ğšğš‘ğš ğšğš’ğš›ğšœğš ğš™ğšğš›ğšœğš˜ğš— ğšğš˜ ğšŠğšŒğšŒğšğšœğšœ ğšğš‘ğš ğš£ğš˜ğšğš’ğšŠğšŒ ğš ğšŠğš•ğš•ğšğš... ğš ğš’ğš—ğšœ

ğšœğš˜ğš–ğš ğšŒğš•ğšğšğšœ ğš ğš’ğš•ğš• ğš‹ğš ğšğš‘ğš ğšŒğš•ğšğš ğš’ğšğšœğšğš•ğš ğš ğš‘ğš’ğš•ğš ğš˜ğšğš‘ğšğš›ğšœ ğš ğš’ğš•ğš• ğš•ğšğšŠğš ğšğš˜ ğš˜ğšğš‘ğšğš› ğšŒğš•ğšğšğšœ

ğšœğš˜ğš–ğš ğšŒğš•ğšğšğšœ ğš ğš’ğš•ğš• ğš‹ğš ğš˜ğš‹ğšŸğš’ğš˜ğšğšœ ğš ğš‘ğš’ğš•ğš ğš˜ğšğš‘ğšğš›ğšœ ğš’ğš—ğšŒğš˜ğš—ğšœğš™ğš’ğšŒğšğš˜ğšğšœ

ğšŒğš˜ğšğš•ğš ğšŠ ğšŒğš•ğšğš ğš™ğš˜ğš™ ğšğš™ ğš˜ğš— ğšŠ ğš›ğšŠğš—ğšğš˜ğš– ğš ğšğš‹ğš™ğšŠğšğš ğš˜ğš› ğš™ğš˜ğšœğšœğš’ğš‹ğš•ğš¢ ğšŠğš™ğš™ğšğšŠğš› ğš˜ğš— ğšŠ ğšğšğš™ğš•ğš˜ğš¢ğšğš ğšŒğš˜ğš—ğšğš›ğšŠğšŒğš

ğšŒğš˜ğšğš•ğš ğš˜ğš—ğš ğš‹ğš ğšœğšğš—ğš ğš˜ğš— ğšŠ ğšœğš˜ğšŒğš’ğšŠğš• ğš–ğšğšğš’ğšŠ ğš™ğš•ğšŠğšğšğš˜ğš›ğš– ğš˜ğš› ğš˜ğš—ğš•ğš¢ ğš›ğšğš•ğšŠğš¢ğšğš ğš’ğš— ğšŠ ğš˜ğš—ğš-ğšğš’ğš–ğš ğš™ğš›ğš’ğšŸğšŠğšğš ğšğšğš•ğšğšğš›ğšŠğš– ğšğš›ğš˜ğšğš™

ğš–ğšŠğš¢ğš‹ğš ğšŠ ğšŒğš•ğšğš ğš ğš’ğš•ğš• ğšŠğš™ğš™ğšğšŠğš› ğš˜ğš— ğšŠ ğ™½ğ™µğšƒ, ğš˜ğš› ğš‘ğš’ğšğšğšğš— ğš ğš’ğšğš‘ğš’ğš— ğšŠ ğšœğšğš›ğš’ğšğšœ

ğš’ğš ğš’ğšœ ğšğš˜ğš› ğš¢ğš˜ğš ğšğš˜ ğšğš’ğš—ğš ğš˜ğšğš

ğšğš‘ğš ğšŠğšŸğšŠğš’ğš•ğšŠğš‹ğš•ğš ğš–ğšğšğš’ğšğš–ğšœ ğšŠğš—ğš ğš–ğšğšğš‘ğš˜ğšğšœ ğšŠğš›ğš ğšğš—ğšğš•ğšğšœğšœ

ğšğš˜ ğš—ğš˜ğš ğšğšŠğš•ğš• ğšğš˜ğš› ğšğšŠğš•ğšœğš ğš™ğš›ğš˜ğš™ğš‘ğšğšğšœ

ğš—ğšŠğš–ğš, ğš ğšŠğš•ğš•ğšğš, ğš•ğš’ğš—ğš”ğšœ/ğšœğš˜ğšŒğš’ğšŠğš•ğšœ ğš ğš’ğš•ğš• ğš—ğšğšŸğšğš› ğšŒğš‘ğšŠğš—ğšğš

ğšğš‘ğšğš›ğš ğš ğš’ğš•ğš• ğš˜ğš—ğš•ğš¢ ğšğšŸğšğš› ğš‹ğš ğš˜ğš—ğš ğš˜ğš ğš–ğš

ğš¢ğš˜ğš ğš ğš’ğš•ğš• ğš”ğš—ğš˜ğš  ğš’ğš ğš’ğšœ ğš–ğš

ğš¢ğš˜ğš ğšœğš‘ğšŠğš•ğš• ğš—ğšğšŸğšğš› ğšŒğšŠğšğšŒğš‘ ğš–ğš, ğš‹ğšğšŒğšŠğšğšœğš ğ™¸ ğš‘ğšŠğšŸğš ğš‹ğšğšğš— ğšğš˜ğš˜ ğšŒğš•ğšğšŸğšğš› ğšğš˜ğš› ğš¢ğš˜ğš

ğš•ğš’ğš”ğš ğš’ ğš‘ğšŠğšŸğš ğšŠğš•ğš ğšŠğš¢ğšœ ğšœğšŠğš’ğš ğš’ ğšŠğš– ğšŒğš›ğšŠğšŒğš” ğš™ğš›ğš˜ğš˜ğš

stay tuned...

all the details at https://zodiac.dev

*/

contract Context {
    constructor() {}

    function _msgSender() internal view returns (address payable) {
        return payable(msg.sender);
    }

    function _msgData() internal view returns (bytes memory) {
        this;
        return msg.data;
    }
}

library SafeMath {

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, 'SafeMath: addition overflow');

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, 'SafeMath: subtraction overflow');
    }

    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, 'SafeMath: multiplication overflow');

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, 'SafeMath: division by zero');
    }

    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;

        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, 'SafeMath: modulo by zero');
    }

    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }

    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = x < y ? x : y;
    }

    function sqrt(uint256 y) internal pure returns (uint256 z) {
        if (y > 3) {
            z = y;
            uint256 x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }
}

interface IERC20 {

    function totalSupply() external view returns (uint256);

    function decimals() external view returns (uint8);

    function symbol() external view returns (string memory);

    function name() external view returns (string memory);

    function getOwner() external view returns (address);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount) external returns (bool);

    function allowance(address _owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            'SafeERC20: approve from non-zero to non-zero allowance'
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(
            value,
            'SafeERC20: decreased allowance below zero'
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        bytes memory returndata = address(token).functionCall(data, 'SafeERC20: low-level call failed');
        if (returndata.length > 0) {
            require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');
        }
    }
}

abstract contract Auth {
    address public owner;
    mapping (address => bool) internal authorizations;

    constructor(address _owner) {
        owner = _owner;
        authorizations[_owner] = true; }
    
    modifier onlyOwner() {
        require(isOwner(msg.sender), "!OWNER"); _;
    }

    modifier authorized() {
        require(isAuthorized(msg.sender), "!AUTHORIZED"); _;
    }

    function authorize(address adr) public authorized {
        authorizations[adr] = true;
    }

    function unauthorize(address adr) public authorized {
        authorizations[adr] = false;
    }

    function isOwner(address account) public view returns (bool) {
        return account == owner;
    }

    function isAuthorized(address adr) public view returns (bool) {
        return authorizations[adr];
    }

    function transferOwnership(address payable adr) public authorized {
        owner = adr;
        authorizations[adr] = true;
        emit OwnershipTransferred(adr);
    }

    event OwnershipTransferred(address owner);
}

library Address {

    function isContract(address account) internal view returns (bool) {
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        assembly {
            codehash := extcodehash(account)
        }
        return (codehash != accountHash && codehash != 0x0);
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, 'Address: insufficient balance');

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{value: amount}('');
        require(success, 'Address: unable to send value, recipient may have reverted');
    }

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, 'Address: low-level call failed');
    }

    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return _functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, 'Address: low-level call with value failed');
    }

    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, 'Address: insufficient balance for call');
        return _functionCallWithValue(target, data, value, errorMessage);
    }

    function _functionCallWithValue(
        address target,
        bytes memory data,
        uint256 weiValue,
        string memory errorMessage
    ) private returns (bytes memory) {
        require(isContract(target), 'Address: call to non-contract');

        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {

                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

abstract contract ReentrancyGuard {
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    modifier nonReentrant() {
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
        _status = _ENTERED;
        _;
        _status = _NOT_ENTERED;
    }
}
