/**

ï½šï½ï½„ï½‰ï½ï½ƒï¼ï½„ï½…ï½–

ğ™³ğšğšŠğš› ğ™´ğšğš’ğšğš˜ğš›

ğšğš‘ğš’ğšœ ğš’ğšœ ğšğš‘ğš ğš£ğš˜ğšğš’ğšŠğšŒ ğšœğš™ğšğšŠğš”ğš’ğš—ğš...

ğš’ ğš‘ğšŠğšŸğš ğšŠ ğšğšŠğš–ğš... ğšŠ ğšŸğšğš›ğš¢ ğšœğš’ğš–ğš™ğš•ğš ğšğšŠğš–ğš...

ğšŠ ğšœğšğš›ğš’ğšğšœ ğš˜ğš ğšŒğš•ğšğšğšœ (ğšŒğš’ğš™ğš‘ğšğš›ğšœ, ğš›ğš’ğšğšğš•ğšğšœ, ğšœğš’ğšğš—ğšœ, ğš‘ğšğš—ğšğšœ, ğš•ğšğšŠğšğšœ, ğ™½ğ™µğšƒğšœ) ğš ğš’ğš•ğš• ğšğšğš’ğšğš ğš¢ğš˜ğš ğšğš˜ ğšğš‘ğš ğšğš’ğšœğšŒğš˜ğšŸğšğš›ğš¢ 
ğš˜ğš ğšğš‘ğš ğš£ğš˜ğšğš’ğšŠğšŒ ğš ğšŠğš•ğš•ğšğš'ğšœ ğšœğšğšŒğš›ğšğš ğš™ğšŠğšœğšœğš™ğš‘ğš›ğšŠğšœğš

ğšğš‘ğš ğšğš’ğš›ğšœğš ğš™ğšğš›ğšœğš˜ğš— ğšğš˜ ğšŠğšŒğšŒğšğšœğšœ ğšğš‘ğš ğš£ğš˜ğšğš’ğšŠğšŒ ğš ğšŠğš•ğš•ğšğš... ğš ğš’ğš—ğšœ

ğšœğš˜ğš–ğš ğšŒğš•ğšğšğšœ ğš ğš’ğš•ğš• ğš‹ğš ğšğš‘ğš ğšŒğš•ğšğš ğš’ğšğšœğšğš•ğš ğš ğš‘ğš’ğš•ğš ğš˜ğšğš‘ğšğš›ğšœ ğš ğš’ğš•ğš• ğš•ğšğšŠğš ğšğš˜ ğš˜ğšğš‘ğšğš› ğšŒğš•ğšğšğšœ

ğšœğš˜ğš–ğš ğšŒğš•ğšğšğšœ ğš ğš’ğš•ğš• ğš‹ğš ğš˜ğš‹ğšŸğš’ğš˜ğšğšœ ğš ğš‘ğš’ğš•ğš ğš˜ğšğš‘ğšğš›ğšœ ğš’ğš—ğšŒğš˜ğš—ğšœğš™ğš’ğšŒğšğš˜ğšğšœ

ğšŒğš˜ğšğš•ğš ğšŠ ğšŒğš•ğšğš ğš™ğš˜ğš™ ğšğš™ ğš˜ğš— ğšŠ ğš›ğšŠğš—ğšğš˜ğš– ğš ğšğš‹ğš™ğšŠğšğš ğš˜ğš› ğš™ğš˜ğšœğšœğš’ğš‹ğš•ğš¢ ğšŠğš™ğš™ğšğšŠğš› ğš˜ğš— ğšŠ ğšğšğš™ğš•ğš˜ğš¢ğšğš ğšŒğš˜ğš—ğšğš›ğšŠğšŒğš

ğšŒğš˜ğšğš•ğš ğš˜ğš—ğš ğš‹ğš ğšœğšğš—ğš ğš˜ğš— ğšŠ ğšœğš˜ğšŒğš’ğšŠğš• ğš–ğšğšğš’ğšŠ ğš™ğš•ğšŠğšğšğš˜ğš›ğš– ğš˜ğš› ğš˜ğš—ğš•ğš¢ ğš›ğšğš•ğšŠğš¢ğšğš ğš’ğš— ğšŠ ğš˜ğš—ğš-ğšğš’ğš–ğš ğš™ğš›ğš’ğšŸğšŠğšğš ğšğšğš•ğšğšğš›ğšŠğš– ğšğš›ğš˜ğšğš™

ğš–ğšŠğš¢ğš‹ğš ğšŠ ğšŒğš•ğšğš ğš ğš’ğš•ğš• ğšŠğš™ğš™ğšğšŠğš› ğš˜ğš— ğšŠ ğ™½ğ™µğšƒ, ğš˜ğš› ğš‘ğš’ğšğšğšğš— ğš ğš’ğšğš‘ğš’ğš— ğšŠ ğšœğšğš›ğš’ğšğšœ

ğš’ğš ğš’ğšœ ğšğš˜ğš› ğš¢ğš˜ğš ğšğš˜ ğšğš’ğš—ğš ğš˜ğšğš

ğšğš‘ğš ğšŠğšŸğšŠğš’ğš•ğšŠğš‹ğš•ğš ğš–ğšğšğš’ğšğš–ğšœ ğšŠğš—ğš ğš–ğšğšğš‘ğš˜ğšğšœ ğšŠğš›ğš ğšğš—ğšğš•ğšğšœğšœ

ğšğš˜ ğš—ğš˜ğš ğšğšŠğš•ğš• ğšğš˜ğš› ğšğšŠğš•ğšœğš ğš™ğš›ğš˜ğš™ğš‘ğšğšğšœ

ğš—ğšŠğš–ğš, ğš ğšŠğš•ğš•ğšğš, ğš•ğš’ğš—ğš”ğšœ/ğšœğš˜ğšŒğš’ğšŠğš•ğšœ ğš ğš’ğš•ğš• ğš—ğšğšŸğšğš› ğšŒğš‘ğšŠğš—ğšğš

ğšğš‘ğšğš›ğš ğš ğš’ğš•ğš• ğš˜ğš—ğš•ğš¢ ğšğšŸğšğš› ğš‹ğš ğš˜ğš—ğš ğš˜ğš ğš–ğš

ğš¢ğš˜ğš ğš ğš’ğš•ğš• ğš”ğš—ğš˜ğš  ğš’ğš ğš’ğšœ ğš–ğš

ğš¢ğš˜ğš ğšœğš‘ğšŠğš•ğš• ğš—ğšğšŸğšğš› ğšŒğšŠğšğšŒğš‘ ğš–ğš, ğš‹ğšğšŒğšŠğšğšœğš ğ™¸ ğš‘ğšŠğšŸğš ğš‹ğšğšğš— ğšğš˜ğš˜ ğšŒğš•ğšğšŸğšğš› ğšğš˜ğš› ğš¢ğš˜ğš

ğš•ğš’ğš”ğš ğš’ ğš‘ğšŠğšŸğš ğšŠğš•ğš ğšŠğš¢ğšœ ğšœğšŠğš’ğš ğš’ ğšŠğš– ğšŒğš›ğšŠğšŒğš” ğš™ğš›ğš˜ğš˜ğš

stay tuned...

all the details at https://zodiac.dev

*/

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {return a + b;}
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {return a - b;}
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {return a * b;}
    function div(uint256 a, uint256 b) internal pure returns (uint256) {return a / b;}
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {return a % b;}
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {uint256 c = a + b; if(c < a) return(false, 0); return(true, c);}}
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {if(b > a) return(false, 0); return(true, a - b);}}
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {if (a == 0) return(true, 0); uint256 c = a * b;
        if(c / a != b) return(false, 0); return(true, c);}}
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {if(b == 0) return(false, 0); return(true, a / b);}}
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {if(b == 0) return(false, 0); return(true, a % b);}}
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked{require(b <= a, errorMessage); return a - b;}}
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked{require(b > 0, errorMessage); return a / b;}}
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked{require(b > 0, errorMessage); return a % b;}}}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
    function symbol() external view returns (string memory);
    function name() external view returns (string memory);
    function getOwner() external view returns (address);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address _owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);}

abstract contract Ownable {
    address internal owner;
    constructor(address _owner) {owner = _owner;}
    modifier onlyOwner() {require(isOwner(msg.sender), "!OWNER"); _;}
    function isOwner(address account) public view returns (bool) {return account == owner;}
    function transferOwnership(address payable adr) public onlyOwner {owner = adr; emit OwnershipTransferred(adr);}
    event OwnershipTransferred(address owner);
}

interface IZODIAC {
    function distributeZodiac(uint256 previousBalance) external;
    function currentBalance() external view returns (uint256);
}

interface IFactory{
    function createPair(address tokenA, address tokenB) external returns (address pair);
    function getPair(address tokenA, address tokenB) external view returns (address pair);
}

interface IRouter {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
    
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline) external;
}
